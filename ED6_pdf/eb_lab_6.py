# -*- coding: utf-8 -*-
"""EB_lab_6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gbDLqgzYsrLh-RMgVZNC66ghyUGPt8r3

Zadanie 1
"""

import pandas as pd
import numpy as np

dataEx1 = pd.read_csv('k_means_data.csv')
dataEx1

import matplotlib.pyplot as plt

plt.scatter(dataEx1.iloc[:,0],dataEx1.iloc[:,1])
plt.show()

from sklearn.cluster import AgglomerativeClustering

k = 3
model = AgglomerativeClustering(linkage='single',n_clusters=k,affinity='euclidean', distance_threshold=None) 
model.fit(dataEx1)

model.labels_

from sklearn.cluster import KMeans

k = 3
model = KMeans(n_clusters=3).fit(dataEx1)
model.labels_

K=model.cluster_centers_
K



"""Zadanie 2"""

data = pd.read_csv('k_means_data.csv')
print(data)
data = np.array(data)

Label = np.zeros((len(data),1),dtype=np.float64)
Label

NewData = np.concatenate([data,Label],axis=1)
NewData

NewData[:,2]

minX = int(np.min(data[:,0]))
maxX = int(np.max(data[:,0]))
minY = int(np.min(data[:,1]))
maxY = int(np.max(data[:,1]))
print(minX," ",maxX," ",minY," ",maxY)

import random
CentersX = []
CentersY = []
for _ in range(0,3):
  CentersX.append(random.randrange(minX,maxX))
  CentersY.append(random.randrange(minY,maxY))

CentersX = np.array(CentersX).reshape(3,1)
CentersY = np.array(CentersY).reshape(3,1)

Centers = np.concatenate([CentersX,CentersY],axis=1).astype(np.float64)

Centers

import matplotlib.pyplot as plt
plt.scatter(data[:,0],data[:,1])
plt.scatter(Centers[:,0],Centers[:,1])
plt.show()

import math

for point in NewData:
  print(point[0],point[1])
  i = -1
  j= -1
  print("    ")
  for cent in Centers:
    print("Cent",cent[0],cent[1])
    i= i+1
    euclidesian=math.sqrt(((cent[1]-point[1])*(cent[1]-point[1]))+((cent[0]-point[0])*(cent[0]-point[0])))
    if(i==0):
      min=euclidesian
      j=i
    if(min>euclidesian):
      min=euclidesian
      j=i

    print(euclidesian)
    print("Max"," i ", min,i,j)
    point[2]=j

NewData

NewData[:,2]

OldCenters = Centers
while True:
  x0=0
  y0=0
  i0=0
  x1=0
  y1=0
  i1=0
  x2=0
  y2=0
  i2=0

  Cluster1X=[]
  Cluster1Y=[]
  Cluster2X=[]
  Cluster2Y=[]
  Cluster3X=[]
  Cluster3Y=[]
  for point in NewData:
    print(point[0],point[1],point[2])
    if(point[2]==0):
      x0=x0+point[0]
      Cluster1X.append(point[0])
      y0=y0+point[1]
      Cluster1Y.append(point[1])
      i0=i0+1
    if(point[2]==1):
      x1=x1+point[0]
      Cluster2X.append(point[0])
      y1=y1+point[1]
      Cluster2Y.append(point[1])
      i1=i1+1
    if(point[2]==2):
      x2=x2+point[0]
      Cluster3X.append(point[0])
      y2=y2+point[1]
      Cluster3Y.append(point[1])
      i2=i2+1
    
  NewCentersX=[]
  NewCentersY=[]

  #NewCentersX.append(x0/i0)
  #NewCentersY.append(y0/i0)
  #NewCentersX.append(x1/i1)
  #NewCentersY.append(y1/i1)
  #NewCentersX.append(x2/i2)
  #NewCentersY.append(y2/i2)
  NewCentersX.append(np.mean(Cluster1X))
  NewCentersX.append(np.mean(Cluster2X))
  NewCentersX.append(np.mean(Cluster3X))
  NewCentersY.append(np.mean(Cluster1Y))
  NewCentersY.append(np.mean(Cluster2Y))
  NewCentersY.append(np.mean(Cluster3Y))
  NewCentersX = np.array(NewCentersX).reshape(3,1)
  NewCentersY = np.array(NewCentersY).reshape(3,1)

  print(np.mean(Cluster1X))
  print(np.mean(Cluster1Y))
  print(np.mean(Cluster2X))
  print(np.mean(Cluster2Y))
  print(np.mean(Cluster3X))
  print(np.mean(Cluster3Y))

  NewCenters = np.concatenate([NewCentersX,NewCentersY],axis=1).astype(np.float64)

  print(x0,y0,i0)
  print(x1,y1,i1)
  print(x2,y2,i2)
  plt.scatter(NewData[:,0],NewData[:,1])
  plt.scatter(NewCenters[:,0],NewCenters[:,1])
  plt.show()

  print(OldCenters)
  print(NewCenters)
  print("Space")
  
  if np.array_equal(OldCenters,NewCenters)==True:
    break
  OldCenters = NewCenters
  #NewCenters


  for point in NewData:
    #print(point[0],point[1])
    i = -1
    j= -1
    #print("    ")
    for cent in NewCenters:
      print("Cent",cent[0],cent[1])
      i= i+1
      #euclidesian=math.sqrt(((cent[1]-point[1])*(cent[1]-point[1]))+((cent[0]-point[0])*(cent[0]-point[0])))
      euclidesian=math.sqrt(((cent[0]-point[0])*(cent[0]-point[0]))+((cent[1]-point[1])*(cent[1]-point[1])))
      if(i==0):
        min=euclidesian
        j=i
      if(min>euclidesian):
        min=euclidesian
        j=i

      #print(euclidesian)
      #print("Max"," i ", min,i,j)
      point[2]=j

NewData

test=NewData[:,2]

X=np.asarray(TEST[0])
#print(X)
a=np.asarray(X)
print(a)

df = pd.DataFrame(NewData, columns = ['X','Y','L'])

df.head()

dataset = df[["X", "Y"]]

import seaborn as sns
fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(15,5))
sns.scatterplot(ax=axes[0], data=df, x='X', y='Y').set_title('Bez klastr√≥w')
sns.scatterplot(ax=axes[1], data=df, x='X', y='Y', hue=test).set_title('Z klastrami');

NewData

"""Zadanie 3"""

def lcs(X, Y, m, n):
 
    if m == 0 or n == 0:
       return 0;
    elif X[m-1] == Y[n-1]:
       return 1 + lcs(X, Y, m-1, n-1);
    else:
       return max(lcs(X, Y, m, n-1), lcs(X, Y, m-1, n));
 
 
X = "abcde"
Y = "bcdxy"
print ("Length of LCS is ", lcs(X, Y, len(X), len(Y)))

"""Zadanie 4"""

dataEx4 = pd.read_csv('iris.csv')
dataEx4

dataEx4.describe()

colors = {'virginica':'red', 'setosa':'blue','versicolor':'yellow'}
plt.scatter(dataEx4.iloc[:,0],dataEx4.iloc[:,1],c=dataEx4.iloc[:,4].map(colors))

plt.show()

cor = dataEx4.iloc[:,:].corr()
cor.style.background_gradient(cmap='coolwarm')

colors = {'virginica':'red', 'setosa':'blue','versicolor':'yellow'}
plt.scatter(dataEx4.iloc[:,2],dataEx4.iloc[:,3],c=dataEx4.iloc[:,4].map(colors))

plt.show()

"""5.TAK"""

test=dataEx4.copy()

test.info()

trainingData=pd.DataFrame(data=dataEx4,columns=['sepal_length','sepal_width',],copy=True)

k = 3
model2 = AgglomerativeClustering(linkage='average',n_clusters=k,affinity='euclidean', distance_threshold=None) 
model2.fit(trainingData)

model2.labels_

k = 3
model2 = KMeans(n_clusters=3).fit(trainingData)
model2.labels_